{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "024c325a",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.239126Z",
     "start_time": "2022-04-04T15:29:19.922970Z"
    }
   },
   "outputs": [],
   "source": [
    "from csromer.simulation import FaradayThinSource,FaradayThickSource\n",
    "from csromer.reconstruction import Parameter\n",
    "import numpy as np\n",
    "from IPython.display import clear_output\n",
    "from csromer.io import Reader, Writer\n",
    "from csromer.base import Dataset\n",
    "from csromer.transformers import DFT1D, NUFFT1D\n",
    "import matplotlib.pyplot as plt\n",
    "from csromer.objectivefunction import OFunction\n",
    "from csromer.utils import real_to_complex, complex_to_real\n",
    "from csromer.objectivefunction import TSV, TV, L1, Chi2\n",
    "from csromer.optimization import FISTA, ADMM, SDMM, GradientBasedMethod\n",
    "from csromer.utils import Gaussian\n",
    "from csromer.dictionaries.discrete import DiscreteWavelet\n",
    "from csromer.dictionaries.undecimated import UndecimatedWavelet\n",
    "from csromer.transformers import Gridding\n",
    "from scipy.constants import c\n",
    "from pynufft import NUFFT\n",
    "from scipy import signal as sci_signal\n",
    "import itertools\n",
    "import copy\n",
    "import pandas as pd\n",
    "import time\n",
    "import pywt\n",
    "import os\n",
    "%matplotlib inline\n",
    "#np.random.seed(666)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "1d59c1d4",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.242299Z",
     "start_time": "2022-04-04T15:29:21.239969Z"
    }
   },
   "outputs": [],
   "source": [
    "def gini_coefficient(w):\n",
    "    # Order vector\n",
    "    w_ordered = np.sort(np.abs(w), kind=\"stable\")\n",
    "    l1_norm = np.sum(np.abs(w_ordered))\n",
    "    M = len(w_ordered)\n",
    "    m = np.arange(0, M)\n",
    "    const = (M - m + 1.5)/M\n",
    "    if l1_norm == 0.0:\n",
    "        coeff = np.nan\n",
    "    else:\n",
    "        coeff = np.sum((w_ordered/l1_norm)*const)\n",
    "    return 1.0 - 2.0 * coeff"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "8c3ce1c3",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.309019Z",
     "start_time": "2022-04-04T15:29:21.243440Z"
    }
   },
   "outputs": [],
   "source": [
    "def chi2_calc(residuals):\n",
    "    if residuals.dtype == np.complex64 or residuals.dtype == np.complex128:\n",
    "        data = residuals.real**2 + residuals.imag**2\n",
    "    else:\n",
    "        data = residuals**2\n",
    "    return np.sum(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "30848b9d",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.357436Z",
     "start_time": "2022-04-04T15:29:21.309861Z"
    }
   },
   "outputs": [],
   "source": [
    "def aicbic(residuals, x):\n",
    "    rss = chi2_calc(residuals)\n",
    "    if x.dtype == np.complex64 or x.dtype == np.complex128:\n",
    "        df = np.count_nonzero(x.real) + np.count_nonzero(x.imag)\n",
    "    else:     \n",
    "        df = np.count_nonzero(x)\n",
    "    l = 2*len(residuals)\n",
    "    return l*np.log(rss/l) + 2*df, l*np.log(rss/l) + df*np.log(l)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "c4b50cda",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.418281Z",
     "start_time": "2022-04-04T15:29:21.358280Z"
    }
   },
   "outputs": [],
   "source": [
    "def list_to2darray(x: list = None, cols: int = None, dtype=None):\n",
    "    b = list(map(list, zip(*[iter(x)]*cols)))\n",
    "    #b = [x[cols*i : cols*(i+1)] for i in range(rows)]\n",
    "    if dtype is None:\n",
    "        return np.array(b)\n",
    "    else:\n",
    "        return np.array(b, dtype=dtype)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "441e68a2",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.468072Z",
     "start_time": "2022-04-04T15:29:21.419086Z"
    }
   },
   "outputs": [],
   "source": [
    "class statistics:\n",
    "    def __init__(self, m, n, z):\n",
    "        self.sum = np.zeros((m,n), dtype=np.float32)\n",
    "        self.sum2 = np.zeros((m,n), dtype=np.float32)\n",
    "        self.n = z * np.ones((m,n), dtype=np.int32)\n",
    "    \n",
    "    def cumul(self, x):\n",
    "        x_values = np.where(x != np.nan, x, 0.0)\n",
    "        subtract = np.where(x == np.nan, -1, 0)\n",
    "        self.sum  += x_values\n",
    "        self.sum2 += x_values * x_values\n",
    "        self.n += subtract\n",
    "    \n",
    "    def mean(self):\n",
    "        return np.where(self.n > 0, self.sum / self.n, np.nan)\n",
    "    \n",
    "    def std(self):\n",
    "        return np.where(self.n > 0, np.sqrt(self.sum2/self.n - self.sum*self.sum/self.n/self.n), np.nan)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "74c19991",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.519999Z",
     "start_time": "2022-04-04T15:29:21.468982Z"
    }
   },
   "outputs": [],
   "source": [
    "class Test:\n",
    "    def __init__(self, nu_min=None, nu_max=None, nchannels=None, noise_frac=None, remove_frac=None, use_gridding=False, ftransform=\"nufft\", use_wavelet=None, source_1=None, source_2=None, scenario=1, append_signal=False):\n",
    "        self.nu_min = nu_min\n",
    "        self.nu_max = nu_max\n",
    "        self.nchannels = nchannels\n",
    "        self.noise_frac = noise_frac\n",
    "        self.remove_frac = remove_frac\n",
    "        self.use_gridding=use_gridding\n",
    "        self.use_wavelet = use_wavelet\n",
    "        self.ftransform = ftransform\n",
    "        self.scenario = scenario\n",
    "        self.append_signal = append_signal\n",
    "        self.nu = np.linspace(start=nu_min, stop=nu_max, num=nchannels)\n",
    "        self.source_1 = copy.deepcopy(source_1)\n",
    "        self.source_2 = copy.deepcopy(source_2)\n",
    "\n",
    "        if self.source_1 is not None:\n",
    "            self.source_1.nu = self.nu\n",
    "            self.source_1.simulate()\n",
    "                \n",
    "        if self.source_2 is not None:\n",
    "            self.source_2.nu = self.nu\n",
    "            self.source_2.simulate()\n",
    "                \n",
    "        if scenario == 1:\n",
    "            self.source = self.source_1\n",
    "        elif scenario == 2:\n",
    "            self.source = self.source_2\n",
    "        elif scenario == 3:\n",
    "            self.source = self.source_1 + self.source_2\n",
    "        else:\n",
    "            raise ValueError(\"This scenario does not exist\")\n",
    "            \n",
    "        if remove_frac:\n",
    "            self.source.remove_channels(remove_frac, np.random.RandomState(int(time.time())))\n",
    "        \n",
    "        self.noiseless_source = copy.deepcopy(self.source)\n",
    "        \n",
    "        if scenario == 1:\n",
    "            self.avg_signal = np.abs(self.source_1.s_nu)\n",
    "        elif scenario == 2:\n",
    "            self.avg_signal = np.abs(self.source_2.s_nu)\n",
    "        else:\n",
    "            self.avg_signal = (np.abs(self.source_1.s_nu) + np.abs(self.source_2.s_nu))/2.0\n",
    "        \n",
    "        if noise_frac:\n",
    "            self.source.apply_noise(self.avg_signal*self.noise_frac)\n",
    "                \n",
    "        if use_gridding:\n",
    "            gridding = Gridding(self.source)\n",
    "            gridding_noiseless = Gridding(self.noiseless_source)\n",
    "            self.source = gridding.run()\n",
    "            self.noiseless_source = gridding_noiseless.run()\n",
    "    \n",
    "    def apply_noise(self):\n",
    "        if self.noise_frac:\n",
    "            self.source.apply_noise(self.avg_signal*self.noise_frac, np.random.RandomState(int(time.time())))\n",
    "            \n",
    "    def run(self, lambda_tv:float=None, lambda_tsv:float=None):\n",
    "        self.parameter = Parameter()\n",
    "        self.parameter.calculate_cellsize(dataset=self.source)\n",
    "        \n",
    "        dft = DFT1D(dataset=self.source, parameter=self.parameter)\n",
    "        \n",
    "        self.F_dirty = dft.backward(self.source.data)\n",
    "\n",
    "        if self.use_wavelet:\n",
    "            #self.wavelet = DiscreteWavelet(wavelet_name=self.use_wavelet, mode=\"periodization\", append_signal=self.append_signal)\n",
    "            self.wavelet = UndecimatedWavelet(wavelet_name=self.use_wavelet, mode=\"periodization\", append_signal=self.append_signal)\n",
    "            self.lambda_l1 = np.sqrt(len(self.source.data) + 2*np.sqrt(len(self.source.data))) * 2.0 * np.sqrt(2) * np.mean(self.source.sigma)\n",
    "        else:\n",
    "            self.lambda_l1 = np.sqrt(len(self.source.data) + 2*np.sqrt(len(self.source.data))) * np.sqrt(2) * np.mean(self.source.sigma)\n",
    "        \n",
    "        if lambda_tv is None:\n",
    "            lambda_tv = 0.0\n",
    "        \n",
    "        if lambda_tsv is None:\n",
    "            lambda_tsv = 0.0\n",
    "            \n",
    "        if self.ftransform == \"nufft\":\n",
    "            nufft = NUFFT1D(dataset=self.source, parameter=self.parameter, solve=True)\n",
    "            if self.use_wavelet:\n",
    "                chi2 = Chi2(dft_obj=nufft, wavelet=self.wavelet)\n",
    "            else:\n",
    "                chi2 = Chi2(dft_obj=nufft)\n",
    "        else:\n",
    "            if self.use_wavelet:\n",
    "                chi2 = Chi2(dft_obj=dft, wavelet=self.wavelet)\n",
    "            else:\n",
    "                chi2 = Chi2(dft_obj=dft)\n",
    "            \n",
    "        l1 = L1(reg=self.lambda_l1)\n",
    "        tsv = TSV(reg=lambda_tsv)\n",
    "        tv = TV(reg=lambda_tv)\n",
    "        F_func = [chi2, l1, tsv]\n",
    "        f_func = [chi2]\n",
    "        g_func = [l1, tsv]\n",
    "\n",
    "        F_obj = OFunction(F_func)\n",
    "        f_obj = OFunction(f_func)\n",
    "        g_obj = OFunction(g_func)\n",
    "        \n",
    "        self.parameter.data = self.F_dirty\n",
    "        \n",
    "        self.parameter.complex_data_to_real()\n",
    "        \n",
    "        if self.use_wavelet:\n",
    "            self.parameter.data = self.wavelet.decompose(self.parameter.data)\n",
    "            opt = FISTA(guess_param=self.parameter, F_obj=F_obj, fx=chi2, gx=g_obj, noise=2.0*self.source.theo_noise, verbose=False)\n",
    "        else:\n",
    "            opt = FISTA(guess_param=self.parameter, F_obj=F_obj, fx=chi2, gx=g_obj, noise=self.source.theo_noise, verbose=False)\n",
    "        \n",
    "        self.obj, self.X = opt.run()\n",
    "        \n",
    "        if self.use_wavelet is not None:\n",
    "            self.coeffs = copy.deepcopy(self.X.data)\n",
    "            k = np.count_nonzero(self.coeffs)\n",
    "            self.sparsity = k/len(self.coeffs)\n",
    "            self.gini = gini_coefficient(self.coeffs)\n",
    "            self.X.data = self.wavelet.reconstruct(self.X.data)\n",
    "            self.aic, self.bic = aicbic(self.source.residual, self.coeffs)\n",
    "            \n",
    "        else:\n",
    "            k = np.count_nonzero(self.X.data)\n",
    "            self.sparsity = k/len(self.X.data)\n",
    "            self.gini = gini_coefficient(self.X.data)\n",
    "            self.aic, self.bic = aicbic(self.source.residual, self.X.data)\n",
    "        \n",
    "        \n",
    "        self.X.real_data_to_complex()\n",
    "        \n",
    "        self.X_residual = dft.backward(self.source.residual)\n",
    "        \n",
    "        self.X_restored = self.X.convolve() + self.X_residual\n",
    "        \n",
    "        self.res_noise = 0.5*(np.std(self.X_residual.real) + np.std(self.X_residual.imag))\n",
    "        self.rmse = np.sqrt(np.sum(self.source.residual.real**2 + self.source.residual.imag**2)/(2*len(self.source.residual)))\n",
    "        meaningful_signal = np.where(np.abs(self.parameter.phi) < self.parameter.max_faraday_depth)\n",
    "        self.signal = np.mean(np.abs(self.X_restored[meaningful_signal]))\n",
    "        self.peak_signal = np.max(np.abs(self.X_restored))\n",
    "        \n",
    "        self.snr = self.signal / self.res_noise\n",
    "        self.psnr = self.peak_signal / self.res_noise\n",
    "        \n",
    "        print(\"Signal-to-noise ratio: {0}\".format(self.snr))\n",
    "        print(\"Peak Signal-to-noise ratio: {0}\".format(self.psnr))\n",
    "        print(\"Standard deviation: {0}\".format(self.res_noise))\n",
    "        \n",
    "        # self.lags, self.autocorr_res, self.autocorr_res_sq, self.bound, self.percentage_real_in, self.percentage_imag_in, self.percentage_real_in_sq, self.percentage_imag_in_sq = self.source.assess_residuals()\n",
    "        \n",
    "        # self.residual_comparison = self.noiseless_source.data - self.source.model_data\n",
    "        \"\"\"\n",
    "        \n",
    "        self.fig, self.ax = plt.subplots(nrows=2, ncols=4, sharey='row', figsize=(18, 5))\n",
    "\n",
    "        # Data\n",
    "        self.ax[0,0].plot(self.source.lambda2, self.source.data.real, 'k.', label=r\"Stokes $Q$\")\n",
    "        self.ax[0,0].plot(self.source.lambda2, self.source.data.imag, 'c.', label=r\"Stokes $U$\")\n",
    "        self.ax[0,0].plot(self.source.lambda2, np.abs(self.source.data), 'g.', label=r\"$|P|$\")\n",
    "        self.ax[0,0].set_xlabel(r'$\\lambda^2$[m$^{2}$]')\n",
    "        self.ax[0,0].set_ylabel(r'Jy/beam')\n",
    "        self.ax[0,0].title.set_text(\"Data\")\n",
    "\n",
    "        self.ax[1,0].plot(self.parameter.phi, self.F_dirty.real, 'c--', label=r\"Stokes $Q$\")\n",
    "        self.ax[1,0].plot(self.parameter.phi, self.F_dirty.imag, 'c:', label=r\"Stokes $U$\")\n",
    "        self.ax[1,0].plot(self.parameter.phi, np.abs(self.F_dirty), 'k-', label=r\"|P|\")\n",
    "        self.ax[1,0].set_xlabel(r'$\\phi$[rad m$^{-2}$]')\n",
    "        self.ax[1,0].set_ylabel(r'Jy/beam m$^2$ rad$^{-1}$ rmtf$^{-1}$')\n",
    "        self.ax[1,0].set_xlim([-1000,1000])\n",
    "\n",
    "        # Model\n",
    "        self.ax[0,1].plot(self.source.lambda2, self.source.model_data.real, 'k.', label=r\"Stokes $Q$\")\n",
    "        self.ax[0,1].plot(self.source.lambda2, self.source.model_data.imag, 'c.', label=r\"Stokes $U$\")\n",
    "        self.ax[0,1].plot(self.source.lambda2, np.abs(self.source.model_data), 'g.', label=r\"$|P|$\")\n",
    "        self.ax[0,1].set_xlabel(r'$\\lambda^2$[m$^{2}$]')\n",
    "        self.ax[0,1].set_ylabel(r'Jy/beam')\n",
    "        self.ax[0,1].title.set_text(\"Model\")\n",
    "\n",
    "        self.ax[1,1].get_shared_y_axes().remove(self.ax[1,1])\n",
    "        self.ax[1,1].clear()\n",
    "        self.ax[1,1].plot(self.parameter.phi, self.X.data.real, 'c--', label=r\"Stokes $Q$\")\n",
    "        self.ax[1,1].plot(self.parameter.phi, self.X.data.imag, 'c:', label=r\"Stokes $U$\")\n",
    "        self.ax[1,1].plot(self.parameter.phi, np.abs(self.X.data), 'k-', label=r\"$|P|$\")\n",
    "        self.ax[1,1].set_xlabel(r'$\\phi$[rad m$^{-2}$]')\n",
    "        self.ax[1,1].set_ylabel(r'Jy/beam m$^2$ rad$^{-1}$ pix$^{-1}$')\n",
    "        self.ax[1,1].set_xlim([-1000,1000])\n",
    "        \n",
    "        # Residual\n",
    "\n",
    "        self.ax[0,2].plot(self.source.lambda2, self.source.residual.real, 'k.', label=r\"Stokes $Q$\")\n",
    "        self.ax[0,2].plot(self.source.lambda2, self.source.residual.imag, 'c.', label=r\"Stokes $U$\")\n",
    "        self.ax[0,2].plot(self.source.lambda2, np.abs(self.source.residual), 'g.', label=r\"$|P|$\")\n",
    "        self.ax[0,2].set_xlabel(r'$\\lambda^2$[m$^{2}$]')\n",
    "        self.ax[0,2].set_ylabel(r'Jy/beam')\n",
    "        self.ax[0,2].title.set_text(\"Residual\")\n",
    "\n",
    "        self.ax[1,2].plot(self.parameter.phi, self.X_residual.real, 'c--', label=r\"Stokes $Q$\")\n",
    "        self.ax[1,2].plot(self.parameter.phi, self.X_residual.imag, 'c:', label=r\"Stokes $U$\")\n",
    "        self.ax[1,2].plot(self.parameter.phi, np.abs(self.X_residual), 'k-', label=r\"$|P|$\")\n",
    "        self.ax[1,2].set_xlabel(r'$\\phi$[rad m$^{-2}$]')\n",
    "        self.ax[1,2].set_ylabel(r'Jy/beam m$^2$ rad$^{-1}$ rmtf$^{-1}$')\n",
    "        self.ax[1,2].set_xlim([-1000,1000])\n",
    "        \n",
    "        if self.use_wavelet:\n",
    "            self.ax[0,3].get_shared_y_axes().remove(self.ax[0,3])\n",
    "            self.ax[0,3].clear()\n",
    "            self.ax[0,3].plot(self.coeffs)\n",
    "            self.ax[0,3].title.set_text(\"Coefficients\")\n",
    "\n",
    "        self.ax[1,3].plot(self.parameter.phi, self.X_restored.real, 'c--', label=r\"Stokes $Q$\")\n",
    "        self.ax[1,3].plot(self.parameter.phi, self.X_restored.imag, 'c:', label=r\"Stokes $U$\")\n",
    "        self.ax[1,3].plot(self.parameter.phi, np.abs(self.X_restored), 'k-', label=r\"$|P|$\")\n",
    "        self.ax[1,3].set_xlim([-1000,1000])\n",
    "        self.ax[1,3].set_xlabel(r'$\\phi$[rad m$^{-2}$]')\n",
    "        self.ax[1,3].set_ylabel(r'Jy/beam m$^2$ rad$^{-1}$ rmtf$^{-1}$')\n",
    "        self.ax[1,3].title.set_text(\"Restored\")\n",
    "        \n",
    "        self.fig.tight_layout()\n",
    "        \"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "dd9c11eb",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.585865Z",
     "start_time": "2022-04-04T15:29:21.520816Z"
    }
   },
   "outputs": [],
   "source": [
    "def run_test(source_1, source_2, nsigma, remove_frac, nu_min=1.008e9, nu_max=2.031e9, nchannels=1000, scenario=1, use_wavelet=None, append_signal=False):\n",
    "    nosigma_objs = []\n",
    "    for remv_frac in remove_frac:\n",
    "        nosigma_objs.append(Test(nu_min=nu_min, nu_max=nu_max, nchannels=nchannels, noise_frac=0.0, remove_frac=remv_frac, scenario=scenario, source_1=source_1, source_2=source_2, use_wavelet=use_wavelet, append_signal=append_signal))\n",
    "\n",
    "    test_objs = []\n",
    "    for nsig in nsigma:\n",
    "        for i in range(0, len(remove_frac)):\n",
    "            copy_object = copy.deepcopy(nosigma_objs[i])\n",
    "            copy_object.noise_frac = nsig\n",
    "            copy_object.apply_noise()\n",
    "            test_objs.append(copy_object)\n",
    "\n",
    "    del nosigma_objs\n",
    "\n",
    "    nid = len(nsigma)*len(remove_frac)\n",
    "    for _id in range(0, nid):\n",
    "        test_objs[_id].run()\n",
    "    \n",
    "    return test_objs "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "edfe2e9b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.647285Z",
     "start_time": "2022-04-04T15:29:21.586691Z"
    }
   },
   "outputs": [],
   "source": [
    "# JVLA 1.008 - 2.031 GHz 546 channels\n",
    "# MeerKAT 0.9 GHz-1.420 GHz 546\n",
    "# eMERLIN 1.230 - 1.740 GHz 4096\n",
    "def run_tests(source_1, source_2, nsigma, remove_frac, nsamples, nu_min=1.008e9, nu_max=2.031e9, nchannels=1000, scenario=1, use_wavelet=None, append_signal=False):\n",
    "    m = len(nsigma)\n",
    "    n = len(remove_frac)\n",
    "    w_len = len(use_wavelet)\n",
    "    psnrs = statistics(m, n, nsamples*w_len)\n",
    "    rmses = statistics(m, n, nsamples*w_len)\n",
    "    #noises = statistics(m, n, nsamples*w_len)\n",
    "    sparsities = statistics(m, n, nsamples*w_len)\n",
    "    #ginies = statistics(m, n, nsamples*w_len)\n",
    "    aics = statistics(m, n, nsamples*w_len)\n",
    "    bics = statistics(m, n, nsamples*w_len)\n",
    "    for j in range(0, w_len):\n",
    "        for i in range(0, nsamples):\n",
    "            test = run_test(source_1, source_2, nsigma, remove_frac, nu_min=nu_min, nu_max=nu_max, nchannels=nchannels, scenario=scenario, use_wavelet=use_wavelet[j], append_signal=append_signal)\n",
    "            psnrs.cumul(list_to2darray([x.psnr for x in test], n, dtype=np.float32))\n",
    "            #noises.cumul(list_to2darray([x.res_noise for x in test], n, dtype=np.float32))\n",
    "            sparsities.cumul(list_to2darray([x.sparsity*100.0 for x in test], n, dtype=np.float32))\n",
    "            #ginies.cumul(list_to2darray([x.gini for x in test], n, dtype=np.float32))\n",
    "            rmses.cumul(list_to2darray([x.rmse for x in test], n, dtype=np.float32))\n",
    "            aics.cumul(list_to2darray([x.aic for x in test], n, dtype=np.float32))\n",
    "            bics.cumul(list_to2darray([x.bic for x in test], n, dtype=np.float32))\n",
    "            for t in test:\n",
    "                del t\n",
    "            test = []\n",
    "    \n",
    "    psnr_mean, psnr_std = psnrs.mean(), psnrs.std()\n",
    "    rmse_mean, rmse_std = rmses.mean(), rmses.std()\n",
    "    #noise_mean, noise_std = noises.mean(), noises.std()\n",
    "    sparsity_mean, sparsity_std = sparsities.mean(), sparsities.std()\n",
    "    #gini_mean, gini_std = ginies.mean(), ginies.std()\n",
    "    aic_mean, aic_std = aics.mean(), aics.std()\n",
    "    bic_mean, bic_std = bics.mean(), bics.std()\n",
    "    return psnr_mean, psnr_std, rmse_mean, rmse_std, aic_mean, aic_std, bic_mean, bic_std, sparsity_mean, sparsity_std"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "2df5426b",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.707344Z",
     "start_time": "2022-04-04T15:29:21.648055Z"
    }
   },
   "outputs": [],
   "source": [
    "source_1 = FaradayThinSource(s_nu=0.0035, phi_gal=-200, spectral_idx=1.0)\n",
    "source_2 = FaradayThickSource(s_nu=0.0035, phi_fg=140, phi_center=200, spectral_idx=1.0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "e7e34513",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-04T15:29:21.760472Z",
     "start_time": "2022-04-04T15:29:21.708359Z"
    }
   },
   "outputs": [],
   "source": [
    "nsigma = [0.2]\n",
    "remove_frac = [0.2]\n",
    "scenarios=[1,2,3]\n",
    "families=[\"coif\", \"db\", \"dmey\", \"sym\"]\n",
    "#use_wavelet= pywt.wavelist(kind=\"discrete\").remove(\"db1\")\n",
    "#use_wavelet = [\"db1\", \"coif1\", \"coif2\"]\n",
    "#use_wavelet = pywt.wavelist(\"coif\", kind=\"discrete\")\n",
    "#use_wavelet.remove(\"haar\")\n",
    "#nwavelets = len(use_wavelet)\n",
    "#use_wavelet=None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "f9cc3e0e",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-05T13:23:53.834411Z",
     "start_time": "2022-04-04T15:29:21.762569Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Wavelets in this family:  ['coif1', 'coif2', 'coif3', 'coif4', 'coif5', 'coif6', 'coif7', 'coif8', 'coif9', 'coif10', 'coif11', 'coif12', 'coif13', 'coif14', 'coif15', 'coif16', 'coif17']\n",
      "FWHM of the main peak of the RMTF: 52.102 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20814.748\n",
      "Signal-to-noise ratio: 1.407593428514773\n",
      "Peak Signal-to-noise ratio: 117.56695319088148\n",
      "Standard deviation: 2.69168995146174e-05\n",
      "FWHM of the main peak of the RMTF: 55.389 rad/m^2\n",
      "Maximum recovered width structure: 141.151 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 22128.083\n",
      "Signal-to-noise ratio: 1.4058446885953075\n",
      "Peak Signal-to-noise ratio: 115.11210743885798\n",
      "Standard deviation: 2.793455496430397e-05\n",
      "FWHM of the main peak of the RMTF: 54.453 rad/m^2\n",
      "Maximum recovered width structure: 127.404 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21753.853\n",
      "Signal-to-noise ratio: 1.4227955873468565\n",
      "Peak Signal-to-noise ratio: 121.76678276760347\n",
      "Standard deviation: 2.610648880363442e-05\n",
      "FWHM of the main peak of the RMTF: 52.102 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20814.748\n",
      "Signal-to-noise ratio: 1.3909460872518267\n",
      "Peak Signal-to-noise ratio: 97.26487931325289\n",
      "Standard deviation: 2.906241570599377e-05\n",
      "FWHM of the main peak of the RMTF: 52.826 rad/m^2\n",
      "Maximum recovered width structure: 142.882 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21104.058\n",
      "Signal-to-noise ratio: 1.3891065994198655\n",
      "Peak Signal-to-noise ratio: 103.56448993313235\n",
      "Standard deviation: 2.8840287995990366e-05\n",
      "FWHM of the main peak of the RMTF: 54.195 rad/m^2\n",
      "Maximum recovered width structure: 138.003 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21650.708\n",
      "Signal-to-noise ratio: 1.40355427339172\n",
      "Peak Signal-to-noise ratio: 117.56374543741057\n",
      "Standard deviation: 2.705334554775618e-05\n",
      "FWHM of the main peak of the RMTF: 54.524 rad/m^2\n",
      "Maximum recovered width structure: 143.172 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21782.223\n",
      "Signal-to-noise ratio: 1.3901723295397848\n",
      "Peak Signal-to-noise ratio: 113.7314378804987\n",
      "Standard deviation: 2.90425778075587e-05\n",
      "FWHM of the main peak of the RMTF: 55.050 rad/m^2\n",
      "Maximum recovered width structure: 132.233 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21992.507\n",
      "Signal-to-noise ratio: 1.4114605421407975\n",
      "Peak Signal-to-noise ratio: 119.77993587032978\n",
      "Standard deviation: 2.6252315365127288e-05\n",
      "FWHM of the main peak of the RMTF: 52.666 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21040.178\n",
      "Signal-to-noise ratio: 1.3872148208603685\n",
      "Peak Signal-to-noise ratio: 117.0542513501529\n",
      "Standard deviation: 2.7383319320506416e-05\n",
      "FWHM of the main peak of the RMTF: 52.436 rad/m^2\n",
      "Maximum recovered width structure: 141.438 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20948.190\n",
      "Signal-to-noise ratio: 1.3996072111239173\n",
      "Peak Signal-to-noise ratio: 115.25264687126318\n",
      "Standard deviation: 2.7858328394358978e-05\n",
      "FWHM of the main peak of the RMTF: 53.800 rad/m^2\n",
      "Maximum recovered width structure: 142.015 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21493.020\n",
      "Signal-to-noise ratio: 1.4269750186533714\n",
      "Peak Signal-to-noise ratio: 115.46335624449145\n",
      "Standard deviation: 2.8072201530449092e-05\n",
      "FWHM of the main peak of the RMTF: 53.203 rad/m^2\n",
      "Maximum recovered width structure: 142.159 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21254.692\n",
      "Signal-to-noise ratio: 1.3937135500202322\n",
      "Peak Signal-to-noise ratio: 117.28128627620055\n",
      "Standard deviation: 2.672240589163266e-05\n",
      "FWHM of the main peak of the RMTF: 52.347 rad/m^2\n",
      "Maximum recovered width structure: 142.159 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20912.532\n",
      "Signal-to-noise ratio: 1.4150481103917216\n",
      "Peak Signal-to-noise ratio: 111.3536493545214\n",
      "Standard deviation: 2.7786831196863204e-05\n",
      "FWHM of the main peak of the RMTF: 60.031 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 23982.325\n",
      "Signal-to-noise ratio: 1.4145517235827563\n",
      "Peak Signal-to-noise ratio: 118.09774941926747\n",
      "Standard deviation: 2.63399924733676e-05\n",
      "FWHM of the main peak of the RMTF: 56.467 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 22558.494\n",
      "Signal-to-noise ratio: 1.4025684562062137\n",
      "Peak Signal-to-noise ratio: 106.05519191325328\n",
      "Standard deviation: 2.71922217507381e-05\n",
      "FWHM of the main peak of the RMTF: 52.102 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20814.748\n",
      "Signal-to-noise ratio: 1.3867547429185096\n",
      "Peak Signal-to-noise ratio: 111.25585899257977\n",
      "Standard deviation: 2.759765447990503e-05\n",
      "FWHM of the main peak of the RMTF: 56.921 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 22739.790\n",
      "Signal-to-noise ratio: 1.4064390761415793\n",
      "Peak Signal-to-noise ratio: 107.96741750400025\n",
      "Standard deviation: 2.8053484129486606e-05\n",
      "FWHM of the main peak of the RMTF: 53.667 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21439.819\n",
      "Signal-to-noise ratio: 1.4061166191013947\n",
      "Peak Signal-to-noise ratio: 120.11186257853966\n",
      "Standard deviation: 2.6921868993667886e-05\n",
      "FWHM of the main peak of the RMTF: 65.504 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 26168.944\n",
      "Signal-to-noise ratio: 1.4083170843591437\n",
      "Peak Signal-to-noise ratio: 112.29544301178696\n",
      "Standard deviation: 2.7400041290093213e-05\n",
      "FWHM of the main peak of the RMTF: 52.102 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20814.748\n",
      "Signal-to-noise ratio: 1.396852332289086\n",
      "Peak Signal-to-noise ratio: 107.15142557771594\n",
      "Standard deviation: 2.800559377647005e-05\n",
      "FWHM of the main peak of the RMTF: 55.125 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 22022.310\n",
      "Signal-to-noise ratio: 1.4885961343273235\n",
      "Peak Signal-to-noise ratio: 110.65633479896987\n",
      "Standard deviation: 2.7413196221459657e-05\n",
      "FWHM of the main peak of the RMTF: 65.413 rad/m^2\n",
      "Maximum recovered width structure: 143.752 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 26132.609\n",
      "Signal-to-noise ratio: 1.405007902713092\n",
      "Peak Signal-to-noise ratio: 114.04431447058177\n",
      "Standard deviation: 2.7313650207361206e-05\n",
      "FWHM of the main peak of the RMTF: 52.206 rad/m^2\n",
      "Maximum recovered width structure: 143.317 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20856.289\n",
      "Signal-to-noise ratio: 1.4410526824083219\n",
      "Peak Signal-to-noise ratio: 114.57295625126982\n",
      "Standard deviation: 2.7371581381885335e-05\n",
      "FWHM of the main peak of the RMTF: 52.102 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20814.748\n",
      "Signal-to-noise ratio: 1.4217543346619057\n",
      "Peak Signal-to-noise ratio: 99.3534254975475\n",
      "Standard deviation: 2.8190539524075575e-05\n",
      "FWHM of the main peak of the RMTF: 52.808 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21096.867\n",
      "Signal-to-noise ratio: 1.4140769907587265\n",
      "Peak Signal-to-noise ratio: 107.42331530375763\n",
      "Standard deviation: 2.7085154215455987e-05\n",
      "FWHM of the main peak of the RMTF: 56.316 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 22498.349\n",
      "Signal-to-noise ratio: 1.4091409687274004\n",
      "Peak Signal-to-noise ratio: 113.55837904110645\n",
      "Standard deviation: 2.6415907996124588e-05\n",
      "FWHM of the main peak of the RMTF: 60.671 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 24238.098\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Signal-to-noise ratio: 1.3952152152752562\n",
      "Peak Signal-to-noise ratio: 110.40129029675455\n",
      "Standard deviation: 2.703210702748038e-05\n",
      "FWHM of the main peak of the RMTF: 52.102 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20814.748\n",
      "Signal-to-noise ratio: 1.3933128523689802\n",
      "Peak Signal-to-noise ratio: 103.4278430530722\n",
      "Standard deviation: 2.837013926182408e-05\n",
      "FWHM of the main peak of the RMTF: 58.835 rad/m^2\n",
      "Maximum recovered width structure: 143.752 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 23504.475\n",
      "Signal-to-noise ratio: 1.4330174719520428\n",
      "Peak Signal-to-noise ratio: 106.10653366360343\n",
      "Standard deviation: 2.612645403132774e-05\n",
      "FWHM of the main peak of the RMTF: 55.420 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 22140.472\n",
      "Signal-to-noise ratio: 1.3921688390105025\n",
      "Peak Signal-to-noise ratio: 113.95182910296447\n",
      "Standard deviation: 2.734123518166598e-05\n",
      "FWHM of the main peak of the RMTF: 52.102 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 20814.748\n",
      "Signal-to-noise ratio: 1.3971739937780385\n",
      "Peak Signal-to-noise ratio: 112.59163373184103\n",
      "Standard deviation: 2.817561835399829e-05\n",
      "FWHM of the main peak of the RMTF: 53.811 rad/m^2\n",
      "Maximum recovered width structure: 144.188 rad/m^2\n",
      "Maximum Faraday Depth to which one has more than 50% sensitivity: 21497.450\n",
      "Signal-to-noise ratio: 1.427400126109887\n",
      "Peak Signal-to-noise ratio: 118.4079916551563\n",
      "S"
     ]
    },
    {
     "data": {
      "text/html": [
       "<b>limit_output extension: Maximum message size of 10000 exceeded with 10219 characters</b>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "names = [\"PSNR\", \"RMSE\", \"AIC\", \"BIC\"] \n",
    "samples=50\n",
    "scenario_means = np.empty((len(scenarios), len(names), len(families)), dtype=np.float32)\n",
    "scenario_stds = np.empty((len(scenarios), len(names), len(families)), dtype=np.float32)\n",
    "append_signal=False\n",
    "for z in range(0, len(families)):\n",
    "    fam = families[z]\n",
    "    use_wavelet = pywt.wavelist(fam, kind=\"discrete\")\n",
    "    print(\"Wavelets in this family: \", use_wavelet)\n",
    "    for i in range(len(scenarios)):\n",
    "        psnr_mean, psnr_std, rmse_mean, rmse_std, aic_mean, aic_std, bic_mean, bic_std, sparsity_mean, sparsity_std = run_tests(source_1, source_2, nsigma, remove_frac, samples, scenario=scenarios[i], use_wavelet=use_wavelet, append_signal=append_signal)\n",
    "        scenario_means[i,0,z] = psnr_mean\n",
    "        scenario_means[i,1,z] = rmse_mean\n",
    "        scenario_means[i,2,z] = aic_mean\n",
    "        scenario_means[i,3,z] = bic_mean\n",
    "\n",
    "        scenario_stds[i,0,z] = psnr_std\n",
    "        scenario_stds[i,1,z] = rmse_std\n",
    "        scenario_stds[i,2,z] = aic_std\n",
    "        scenario_stds[i,3,z] = bic_std\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "fc6a8ad2",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-05T13:23:53.838073Z",
     "start_time": "2022-04-05T13:23:53.835742Z"
    }
   },
   "outputs": [],
   "source": [
    "np.save(\"undecimated_wavelet_jvla_means_50.npy\", scenario_means)\n",
    "np.save(\"undecimated_wavelet_jvla_stds_50.npy\", scenario_stds)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.2"
  },
  "latex_envs": {
   "LaTeX_envs_menu_present": true,
   "autoclose": false,
   "autocomplete": true,
   "bibliofile": "biblio.bib",
   "cite_by": "apalike",
   "current_citInitial": 1,
   "eqLabelWithNumbers": true,
   "eqNumInitial": 1,
   "hotkeys": {
    "equation": "Ctrl-E",
    "itemize": "Ctrl-I"
   },
   "labels_anchors": false,
   "latex_user_defs": false,
   "report_style_numbering": false,
   "user_envs_cfg": false
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
